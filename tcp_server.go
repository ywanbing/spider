package spider

import (
	"crypto/tls"
	"fmt"
	"net"
	"sync"
)

type TcpX struct {
	cfg ConnConfig
	mux *Mux

	// connMap 连接管理
	connMap     map[uint64]TcpConn
	connMapLock sync.RWMutex

	close chan struct{}
}

func NewTcpX(cfgOptions ...ConnConfigOption) *TcpX {
	cfg := defaultConnConfig
	for _, opt := range cfgOptions {
		cfg = opt(cfg)
	}

	return &TcpX{
		cfg:     cfg,
		mux:     newMux(),
		connMap: make(map[uint64]TcpConn),
		close:   make(chan struct{}),
	}
}

// ListenAndServe Start to listen.
// Serve can decode stream generated by packx.
// Support tcp and udp
func (t *TcpX) ListenAndServe(network, addr string) error {
	switch network {
	case "tcp", "tcp4", "tcp6":
		return t.listenAndServeTCP(network, addr)
	default:
		return fmt.Errorf("unsupported network: %s", network)
	}
}

// listenAndServeTCP Start to listen.
func (t *TcpX) listenAndServeTCP(network, addr string) error {
	var (
		listener net.Listener
		err      error
	)

	if t.cfg.tlSConfig == nil {
		listener, err = net.Listen(network, addr)
	} else {
		listener, err = tls.Listen(network, network, t.cfg.tlSConfig)
	}
	if err != nil {
		return err
	}
	defer listener.Close()

	for {
		if t.IsClosed() {
			break
		}

		conn, err := listener.Accept()
		if err != nil {
			return err
		}

		tcpConnObj := NewTcpConn(conn.(*net.TCPConn), t.cfg)
		go t.handleConn(tcpConnObj)
	}

	return err
}

// handleConn 处理连接
func (t *TcpX) handleConn(conn TcpConn) {
	// 前置检查
	if !t.cfg.onConnHandle(conn) {
		_ = conn.Close()
		return
	}

	// 1. 连接管理
	t.connMapLock.Lock()
	t.connMap[conn.GetConnId()] = conn
	t.connMapLock.Unlock()

	// 2. 接收数据
	conn.Start(t)
}

// Close 关闭服务
func (t *TcpX) Close() {
	if !t.IsClosed() {
		close(t.close)
	}
}

// IsClosed 服务是否关闭
func (t *TcpX) IsClosed() bool {
	select {
	case <-t.close:
		return true
	default:
		return false
	}
}

func handleMessage(ctx *Context) {
	modelId := ctx.reqMsg.GetModelId()
	subMsgId := ctx.reqMsg.GetSubMsgId()

	tcpX := ctx.t
	handler, ok := tcpX.mux.Handlers[modelId]
	if !ok {
		// TODO: log
		return
	}

	f, ok := handler.Handlers[subMsgId]
	if !ok {
		// TODO: log
		return
	}

	// 心跳包，默认 modelId = 0
	if tcpX.cfg.HeartBeatOn && subMsgId == tcpX.cfg.HeartBeatMessageID {
		// 心跳包处理
		f(ctx)
		return
	}

	if ctx.handlers == nil {
		ctx.handlers = make([]func(c *Context), 0, 10)
	}

	// global middleware
	ctx.handlers = append(ctx.handlers, tcpX.mux.GlobalMiddles...)
	// model middles
	ctx.handlers = append(ctx.handlers, handler.ModelMiddles...)
	// self-related middleware
	selfMiddles := handler.HandlerMiddles[subMsgId]
	if len(selfMiddles) > 0 {
		ctx.handlers = append(ctx.handlers, selfMiddles...)
	}

	// handler
	ctx.handlers = append(ctx.handlers, f)

	// 执行
	if len(ctx.handlers) > 0 {
		ctx.Next()
	}
}

// RegisterGlobalMiddle add global routing middle handlers.
func (t *TcpX) RegisterGlobalMiddle(middles ...func(ctx *Context)) {
	t.mux.RegisterGlobalMiddle(middles...)
}

// RegisterModelMiddle add routing middle handlers by modelID.
func (t *TcpX) RegisterModelMiddle(id modelID, middles ...func(ctx *Context)) {
	t.mux.RegisterModelMiddle(id, middles...)
}

// RegisterHandler add routing handlers by modelID and subMsgID.
func (t *TcpX) RegisterHandler(id modelID, subID subMsgID, handler func(ctx *Context), middles ...func(ctx *Context)) {
	t.mux.RegisterHandler(id, subID, handler, middles...)
}
