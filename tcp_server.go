package spider

import (
	"crypto/tls"
	"fmt"
	"net"
	"sync"

	"github.com/ywanbing/spider/common"
	"github.com/ywanbing/spider/message"
)

type TcpServer struct {
	cfg ConnConfig
	mux *Mux

	// connMap 连接管理
	connMap       map[uint64]TcpConn
	connMapLock   sync.RWMutex
	addConnChan   chan TcpConn
	closeConnChan chan TcpConn

	listener net.Listener

	close chan struct{}
}

func NewTcpX(cfgOptions ...ConnConfigOption) *TcpServer {
	cfg := defaultConnConfig
	for _, opt := range cfgOptions {
		cfg = opt(cfg)
	}

	return &TcpServer{
		cfg:           cfg,
		mux:           newMux(),
		connMap:       make(map[uint64]TcpConn),
		addConnChan:   make(chan TcpConn, 10),
		closeConnChan: make(chan TcpConn, 10),
		close:         make(chan struct{}),
	}
}

// ListenAndServe Start to listen.
// Serve can decode stream generated by packx.
// Support tcp and udp
func (t *TcpServer) ListenAndServe(network, addr string) error {
	switch network {
	case "tcp", "tcp4", "tcp6":
		return t.listenAndServeTCP(network, addr)
	default:
		return fmt.Errorf("unsupported network: %s", network)
	}
}

// listenAndServeTCP Start to listen.
func (t *TcpServer) listenAndServeTCP(network, addr string) error {
	var (
		err error
	)

	if t.cfg.tlSConfig == nil {
		t.listener, err = net.Listen(network, addr)
	} else {
		t.listener, err = tls.Listen(network, network, t.cfg.tlSConfig)
	}
	if err != nil {
		return err
	}
	defer t.listener.Close()

	// 开启连接管理
	go t.conManger()

	for {
		if t.IsClosed() {
			break
		}

		conn, err := t.listener.Accept()
		if err != nil {
			return err
		}

		tcpConnObj := NewTcpConn(conn.(*net.TCPConn), t.cfg, t.handleMessage)
		go t.handleConn(tcpConnObj)
	}

	return err
}

// handleConn 处理连接
func (t *TcpServer) handleConn(conn TcpConn) {
	// 前置检查
	if !t.cfg.onConnHandle(conn) {
		_ = conn.Close()
		return
	}

	select {
	case t.addConnChan <- conn:
	default:
		// TODO 日志，连接创建太快
		_ = conn.Close()
	}
}

// handleConn 处理连接
func (t *TcpServer) conManger() {
	for {
		select {
		case <-t.close:
			// 1. 关闭所有连接
			t.connMapLock.Lock()
			for _, conn := range t.connMap {
				_ = conn.Close()
			}
			t.connMapLock.Unlock()
			return
		case conn := <-t.addConnChan:
			// 1. 连接管理
			t.connMapLock.Lock()
			// 已经存在连接，关闭之前的连接
			if _, ok := t.connMap[conn.GetConnId()]; ok {
				_ = t.connMap[conn.GetConnId()].Close()
			}

			t.connMap[conn.GetConnId()] = conn
			t.connMapLock.Unlock()

			// 2. 接收数据
			conn.Start()
		case conn := <-t.closeConnChan:
			_ = conn.Close()
			// 1. 连接管理
			t.connMapLock.Lock()
			delete(t.connMap, conn.GetConnId())
			t.connMapLock.Unlock()
		}
	}
}

// Close 关闭服务
func (t *TcpServer) Close() {
	if !t.IsClosed() {
		close(t.close)
		t.listener.Close()
	}
}

// IsClosed 服务是否关闭
func (t *TcpServer) IsClosed() bool {
	select {
	case <-t.close:
		return true
	default:
		return false
	}
}

// RegisterGlobalMiddle add global routing middle handlers.
func (t *TcpServer) RegisterGlobalMiddle(middles ...func(ctx *Context)) {
	t.mux.RegisterGlobalMiddle(middles...)
}

// RegisterModelMiddle add routing middle handlers by modelID.
func (t *TcpServer) RegisterModelMiddle(id modelID, middles ...func(ctx *Context)) {
	t.mux.RegisterModelMiddle(id, middles...)
}

// RegisterHandler add routing handlers by modelID and subMsgID.
func (t *TcpServer) RegisterHandler(id modelID, subID subMsgID, handler func(ctx *Context), middles ...func(ctx *Context)) {
	t.mux.RegisterHandler(id, subID, handler, middles...)
}

// handleMessage 服务器处理消息
func (t *TcpServer) handleMessage(ctx *Context) {
	header := ctx.reqMsg.GetHeader()
	switch header[message.MsgTypeKey] {
	case message.MsgTypeRequest:
		// 请求消息
		t.HandleRequest(ctx)
	case message.MsgTypeHeartBeat:
		// 心跳消息
		t.HandleHeartBeat(ctx)
	default:
		//	TODO log
	}
}

// HandleRequest 处理请求消息
func (t *TcpServer) HandleRequest(ctx *Context) {
	msgId := ctx.reqMsg.GetMsgId()
	modelId := common.GetModelId(msgId)
	subMsgId := common.GetSubMsgId(msgId)

	handler, ok := t.mux.Handlers[modelId]
	if !ok {
		// TODO: log
		return
	}

	f, ok := handler.Handlers[subMsgId]
	if !ok {
		// TODO: log
		return
	}

	if ctx.handlers == nil {
		ctx.handlers = make([]func(c *Context), 0, 10)
	}

	// global middleware
	ctx.handlers = append(ctx.handlers, t.mux.GlobalMiddles...)
	// model middles
	ctx.handlers = append(ctx.handlers, handler.ModelMiddles...)
	// self-related middleware
	selfMiddles := handler.HandlerMiddles[subMsgId]
	if len(selfMiddles) > 0 {
		ctx.handlers = append(ctx.handlers, selfMiddles...)
	}

	// handler
	ctx.handlers = append(ctx.handlers, f)

	// 执行
	if len(ctx.handlers) > 0 {
		ctx.Next()
	}
}

// HandleReply 处理响应消息
func (t *TcpServer) HandleReply(ctx *Context) {

}

// HandlePush 处理推送消息
func (t *TcpServer) HandlePush(ctx *Context) {

}

// HandleHeartBeat 处理心跳消息
func (t *TcpServer) HandleHeartBeat(ctx *Context) {

}
